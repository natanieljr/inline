# This file has been modified by Konrad on Jan 30, 2015.
# Modifications:
# - Commented out some API calls that are hidden or cannot be instrumented for other reasons.
# To find such APIs, search for SKIPPED_API
# - Added some APIs. To find them search for ADDED_API
# - Some of the skipped APIs have replacements. If I am sure given skipped API does NOT have a replacement it is non-supported API.
#   To find such APIs, search for NON_SUPPORTED_API
# - REDUNDANT_APIS are commented out as they delegate to other monitored APIs. They might have been in the original mapping or have been added manually (for documentation) and commented out.

# ADDED_APIs Monitoring of permission checks. For debugging purposes only.
# <android.app.ApplicationPackageManager: int checkPermission(java.lang.String,java.lang.String)>
# <android.app.ContextImpl: int checkPermission(java.lang.String,int,int)>

Permission:android.permission.CHANGE_WIFI_STATE
17 Callers:
<android.net.wifi.WifiManager: boolean reassociate()>
<android.net.wifi.WifiManager: boolean startScan()>
<android.net.wifi.WifiManager: void setCountryCode(java.lang.String,boolean)>
<android.net.ConnectivityManager: int startUsingNetworkFeature(int,java.lang.String)>
<android.net.wifi.WifiManager: boolean disableNetwork(int)>
<android.net.wifi.WifiManager: int updateNetwork(android.net.wifi.WifiConfiguration)>
<android.net.wifi.WifiManager: boolean removeNetwork(int)>
<android.net.wifi.WifiManager: boolean reconnect()>
<android.net.wifi.WifiManager: int addNetwork(android.net.wifi.WifiConfiguration)>

# SKIPPED_API
# <android.net.wifi.p2p.WifiP2pManager: android.net.wifi.p2p.WifiP2pManager$Channel initialize(android.content.Context,android.os.Looper,android.net.wifi.p2p.WifiP2pManager$ChannelListener)>

<android.net.wifi.WifiManager: boolean enableNetwork(int,boolean)>
<android.net.wifi.WifiManager: boolean disconnect()>
<android.net.wifi.WifiManager: boolean setWifiEnabled(boolean)>
<android.net.ConnectivityManager: void setNetworkPreference(int)>
<android.net.wifi.WifiManager: boolean saveConfiguration()>
<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,java.lang.String)>

# SKIPPED_API Nowhere to be found in docs, probably hidden. Doc: http://developer.android.com/reference/android/net/wifi/WifiManager.html
# <android.net.wifi.WifiManager: android.net.wifi.WifiManager$Channel initialize(android.content.Context,android.os.Looper,android.net.wifi.WifiManager$ChannelListener)>

Permission:android.permission.READ_PHONE_STATE
9 Callers:
<android.telephony.TelephonyManager: java.lang.String getSubscriberId()>
<android.telephony.TelephonyManager: java.lang.String getDeviceSoftwareVersion()>
<android.telephony.TelephonyManager: void listen(android.telephony.PhoneStateListener,int)>
<android.telephony.TelephonyManager: java.lang.String getLine1Number()>
<android.telephony.TelephonyManager: java.lang.String getSimSerialNumber()>
<android.net.ConnectivityManager: int startUsingNetworkFeature(int,java.lang.String)>
<android.telephony.TelephonyManager: java.lang.String getVoiceMailAlphaTag()>
<android.telephony.TelephonyManager: java.lang.String getVoiceMailNumber()>
<android.telephony.TelephonyManager: java.lang.String getDeviceId()>
Permission:android.permission.WRITE_CONTACTS
26 Callers:
<android.provider.Contacts$People: void markAsContacted(android.content.ContentResolver,long)>
<android.provider.Contacts$ContactMethods: void addPostalLocation(android.content.Context,long,double,double)>
<android.widget.QuickContactBadge: void assignContactFromPhone(java.lang.String,boolean)>
<android.provider.ContactsContract$ProfileSyncState: byte[] get(android.content.ContentProviderClient,android.accounts.Account)>
<android.provider.Contacts$People: android.database.Cursor queryGroups(android.content.ContentResolver,long)>
<android.provider.ContactsContract$ProfileSyncState: android.content.ContentProviderOperation newSetOperation(android.accounts.Account,byte[])>
<android.provider.ContactsContract$SyncState: void set(android.content.ContentProviderClient,android.accounts.Account,byte[])>
<android.provider.ContactsContract$RawContacts: android.net.Uri getContactLookupUri(android.content.ContentResolver,android.net.Uri)>
<android.provider.Contacts$People: android.net.Uri createPersonInMyContactsGroup(android.content.ContentResolver,android.content.ContentValues)>
<android.provider.Contacts$People: android.net.Uri addToGroup(android.content.ContentResolver,long,java.lang.String)>
<android.provider.Contacts$People: android.net.Uri addToMyContactsGroup(android.content.ContentResolver,long)>
<android.provider.ContactsContract$SyncState: android.util.Pair getWithUri(android.content.ContentProviderClient,android.accounts.Account)>
<android.provider.Contacts$Settings: void setSetting(android.content.ContentResolver,java.lang.String,java.lang.String,java.lang.String)>
<android.provider.ContactsContract$SyncState: android.content.ContentProviderOperation newSetOperation(android.accounts.Account,byte[])>
<android.provider.ContactsContract$Contacts: android.net.Uri getLookupUri(android.content.ContentResolver,android.net.Uri)>
<android.provider.ContactsContract$Contacts: void markAsContacted(android.content.ContentResolver,long)>
<android.provider.ContactsContract$ProfileSyncState: android.util.Pair getWithUri(android.content.ContentProviderClient,android.accounts.Account)>
<android.widget.QuickContactBadge: void onClick(android.view.View)>
<android.provider.ContactsContract$SyncState: byte[] get(android.content.ContentProviderClient,android.accounts.Account)>
<android.widget.QuickContactBadge: void assignContactFromEmail(java.lang.String,boolean)>
<android.provider.ContactsContract$Contacts: android.net.Uri getLookupUri(long,java.lang.String)>
<android.provider.ContactsContract$ProfileSyncState: void set(android.content.ContentProviderClient,android.accounts.Account,byte[])>
<android.provider.Contacts$Settings: java.lang.String getSetting(android.content.ContentResolver,java.lang.String,java.lang.String)>
<android.provider.Contacts$People: android.net.Uri addToGroup(android.content.ContentResolver,long,long)>
<android.provider.ContactsContract$Directory: void notifyDirectoryChange(android.content.ContentResolver)>
<android.provider.ContactsContract$Data: android.net.Uri getContactLookupUri(android.content.ContentResolver,android.net.Uri)>
Permission:android.permission.GET_TASKS
3 Callers:
<android.app.ActivityManager: java.util.List getRecentTasks(int,int)>
<android.app.ActivityManager: java.util.List getRunningTasks(int)>

# SKIPPED_API Nowhere to be found in docs: http://developer.android.com/reference/android/app/ActivityManager.html
# Was in old src and was hidden: https://android.googlesource.com/platform/frameworks/base/+/android-2.3_r1/core/java/android/app/ActivityManager.java
# No trace in current src: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/ActivityManager.java
# <android.app.ActivityManager: java.util.List getRunningTasks(int,int,android.app.IThumbnailReceiver)>

Permission:android.permission.CHANGE_WIFI_MULTICAST_STATE
3 Callers:
<android.net.wifi.WifiManager$MulticastLock: void release()>
<android.net.wifi.WifiManager$MulticastLock: void acquire()>
<android.net.wifi.WifiManager$MulticastLock: void finalize()>
Permission:android.permission.NFC
83 Callers:

# SKIPPED_API Internal method of abstract parent class: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.IsoDep: byte[] transceive(byte[],boolean)>

<android.nfc.tech.MifareClassic: void writeBlock(int,byte[])>
<android.nfc.NfcAdapter: void setOnNdefPushCompleteCallback(android.nfc.NfcAdapter$OnNdefPushCompleteCallback,android.app.Activity,android.app.Activity[])>

# SKIPPED_API Internal method of abstract parent class: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.NfcA: byte[] transceive(byte[],boolean)>

<android.nfc.tech.NfcB: void close()>
<android.nfc.NfcAdapter: void enableForegroundDispatch(android.app.Activity,android.app.PendingIntent,android.content.IntentFilter[],java.lang.String[][])>

# SKIPPED_API Internal method of abstract parent class: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.MifareUltralight: byte[] transceive(byte[],boolean)>

<android.nfc.tech.NfcA: int getTimeout()>
<android.nfc.tech.NfcB: void connect()>
<android.nfc.tech.MifareClassic: byte[] transceive(byte[])>
<android.nfc.tech.NfcV: void close()>
<android.nfc.tech.MifareUltralight: void connect()>
<android.nfc.NfcAdapter: void setNdefPushMessage(android.nfc.NdefMessage,android.app.Activity,android.app.Activity[])>
<android.nfc.tech.MifareClassic: void increment(int,int)>

# SKIPPED_API abstract class. Src: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.BasicTagTechnology: void close()>

<android.nfc.NfcAdapter: void setBeamPushUrisCallback(android.nfc.NfcAdapter$CreateBeamUrisCallback,android.app.Activity)>
<android.nfc.tech.Ndef: void close()>
<android.nfc.tech.Ndef: void reconnect()>
<android.nfc.tech.MifareClassic: void transfer(int)>
<android.nfc.tech.NdefFormatable: void close()>
<android.nfc.tech.MifareClassic: boolean authenticateSectorWithKeyB(int,byte[])>
<android.nfc.tech.NfcF: void reconnect()>
<android.nfc.NfcAdapter: void setNdefPushMessageCallback(android.nfc.NfcAdapter$CreateNdefMessageCallback,android.app.Activity,android.app.Activity[])>
<android.nfc.tech.MifareUltralight: void writePage(int,byte[])>
<android.nfc.tech.NfcF: int getTimeout()>

# SKIPPED_API Internal method of abstract parent class: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.NdefFormatable: byte[] transceive(byte[],boolean)>

# SKIPPED_API abstract class. Src: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.BasicTagTechnology: void reconnect()>

<android.nfc.tech.MifareClassic: void close()>
<android.nfc.tech.Ndef: android.nfc.NdefMessage getNdefMessage()>
<android.nfc.tech.MifareUltralight: void setTimeout(int)>
<android.nfc.tech.MifareClassic: void restore(int)

# SKIPPED_API Internal method of abstract parent class: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.NfcB: byte[] transceive(byte[],boolean)>

<android.nfc.tech.MifareUltralight: int getTimeout()>
<android.nfc.tech.MifareClassic: byte[] readBlock(int)>
<android.nfc.tech.NfcA: void reconnect()>
<android.nfc.tech.NfcV: void connect()>
<android.nfc.tech.NfcF: void close()>
<android.nfc.tech.NfcF: void setTimeout(int)>
<android.nfc.NfcAdapter: void disableForegroundDispatch(android.app.Activity)>
<android.nfc.tech.NdefFormatable: void format(android.nfc.NdefMessage,boolean)>
<android.nfc.tech.NdefFormatable: void reconnect()>
<android.nfc.tech.IsoDep: int getTimeout()>

# SKIPPED_API abstract class. Src: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.BasicTagTechnology: void connect()>

<android.nfc.tech.NdefFormatable: void formatReadOnly(android.nfc.NdefMessage)>
<android.nfc.NfcAdapter: void setBeamPushUris(android.net.Uri[],android.app.Activity)>
<android.nfc.tech.MifareClassic: boolean authenticate(int,byte[],boolean)>

# SKIPPED_API Internal method of abstract parent class: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.MifareClassic: byte[] transceive(byte[],boolean)>

<android.nfc.tech.MifareClassic: void setTimeout(int)>
<android.nfc.tech.MifareUltralight: void close()>

# SKIPPED_API abstract class. Src: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.BasicTagTechnology: byte[] transceive(byte[],boolean)>

<android.nfc.tech.IsoDep: byte[] transceive(byte[])>
<android.nfc.tech.Ndef: void writeNdefMessage(android.nfc.NdefMessage)>
<android.nfc.tech.MifareClassic: int getTimeout()>

# SKIPPED_API Internal method of abstract parent class: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.Ndef: byte[] transceive(byte[],boolean)>

<android.nfc.tech.Ndef: boolean makeReadOnly()>
<android.nfc.tech.NfcB: void reconnect()>
<android.nfc.tech.MifareClassic: void reconnect()>
<android.nfc.tech.MifareUltralight: byte[] transceive(byte[])>
<android.nfc.tech.NfcA: void close()>
<android.nfc.tech.NfcA: void setTimeout(int)>
<android.nfc.NfcAdapter: void enableForegroundNdefPush(android.app.Activity,android.nfc.NdefMessage)>
<android.nfc.tech.IsoDep: void setTimeout(int)>
<android.nfc.tech.IsoDep: void close()>
<android.nfc.tech.NfcV: void reconnect()>
<android.nfc.tech.NfcB: byte[] transceive(byte[])>
<android.nfc.tech.MifareUltralight: byte[] readPages(int)>
<android.nfc.tech.IsoDep: void connect()>
<android.nfc.tech.IsoDep: void reconnect()>
<android.nfc.tech.NdefFormatable: void connect()>
<android.nfc.tech.Ndef: void connect()>
<android.nfc.tech.MifareClassic: void decrement(int,int)>
<android.nfc.tech.NfcV: byte[] transceive(byte[])>
<android.nfc.tech.NfcF: byte[] transceive(byte[])>
<android.nfc.tech.MifareUltralight: void reconnect()>
<android.nfc.tech.NfcA: void connect()>
<android.nfc.tech.MifareClassic: void connect()>
<android.nfc.tech.MifareClassic: boolean authenticateSectorWithKeyA(int,byte[])>
<android.nfc.tech.NdefFormatable: void format(android.nfc.NdefMessage)>

# SKIPPED_API Internal method of abstract parent class: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.NfcV: byte[] transceive(byte[],boolean)>

<android.nfc.tech.NfcA: byte[] transceive(byte[])>
<android.nfc.tech.NfcF: void connect()>
<android.nfc.NfcAdapter: void disableForegroundNdefPush(android.app.Activity)>

# SKIPPED_API Internal method of abstract parent class: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/nfc/tech/BasicTagTechnology.java
# <android.nfc.tech.NfcF: byte[] transceive(byte[],boolean)>

Permission:android.permission.ACCESS_WIFI_STATE
11 Callers:
<android.net.wifi.WifiManager: java.util.List getScanResults()>
<android.net.wifi.p2p.WifiP2pManager: android.net.wifi.p2p.WifiP2pManager$Channel initialize(android.content.Context,android.os.Looper,android.net.wifi.p2p.WifiP2pManager$ChannelListener)>
<android.net.wifi.WifiManager: android.net.DhcpInfo getDhcpInfo()>
<android.net.wifi.WifiManager: boolean pingSupplicant()>

# REDUNDANT_API Manual inspection shows this method only delegates to other monitored method
# <android.net.wifi.WifiManager: boolean isWifiEnabled()>

<android.net.ConnectivityManager: int startUsingNetworkFeature(int,java.lang.String)>
<android.net.wifi.WifiManager: android.net.wifi.WifiInfo getConnectionInfo()>

# SKIPPED_API Nowhere to be found in docs, probably hidden. Doc: http://developer.android.com/reference/android/net/wifi/WifiManager.html
# <android.net.wifi.WifiManager: android.net.wifi.WifiManager$Channel initialize(android.content.Context,android.os.Looper,android.net.wifi.WifiManager$ChannelListener)>

<android.net.wifi.WifiManager: int getWifiState()>
<android.net.wifi.WifiManager: java.util.List getConfiguredNetworks()>

# SKIPPED_APIs appguard fails to generate trampolines on Nexus 7
# <android.net.sip.SipAudioCall: void startAudio()>

Permission:android.permission.SEND_SMS
6 Callers:

# SKIPPED_APIs appguard fails to generate trampolines on Nexus 7
# <android.telephony.gsm.SmsManager: void sendTextMessage(java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent)>
# <android.telephony.SmsManager: void sendMultipartTextMessage(java.lang.String,java.lang.String,java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)>
# <android.telephony.gsm.SmsManager: void sendDataMessage(java.lang.String,java.lang.String,short,byte[],android.app.PendingIntent,android.app.PendingIntent)>
# <android.telephony.SmsManager: void sendTextMessage(java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent)>
# <android.telephony.gsm.SmsManager: void sendMultipartTextMessage(java.lang.String,java.lang.String,java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)>
# <android.telephony.SmsManager: void sendDataMessage(java.lang.String,java.lang.String,short,byte[],android.app.PendingIntent,android.app.PendingIntent)>

Permission:android.permission.ACCESS_MOCK_LOCATION
8 Callers:
<android.location.LocationManager: void clearTestProviderLocation(java.lang.String)>
<android.location.LocationManager: void clearTestProviderEnabled(java.lang.String)>
<android.location.LocationManager: void addTestProvider(java.lang.String,boolean,boolean,boolean,boolean,boolean,boolean,boolean,int,int)>
<android.location.LocationManager: void setTestProviderLocation(java.lang.String,android.location.Location)>
<android.location.LocationManager: void removeTestProvider(java.lang.String)>
<android.location.LocationManager: void setTestProviderEnabled(java.lang.String,boolean)>
<android.location.LocationManager: void clearTestProviderStatus(java.lang.String)>
<android.location.LocationManager: void setTestProviderStatus(java.lang.String,int,android.os.Bundle,long)>
Permission:com.android.voicemail.permission.ADD_VOICEMAIL
3 Callers:
<android.provider.CallLog$Calls: java.lang.String getLastOutgoingCall(android.content.Context)>
<android.provider.VoicemailContract$Status: android.net.Uri buildSourceUri(java.lang.String)>
<android.provider.VoicemailContract$Voicemails: android.net.Uri buildSourceUri(java.lang.String)>
Permission:android.permission.BLUETOOTH_ADMIN
22 Callers:
<android.media.AudioManager: void setMode(int)>
<android.bluetooth.BluetoothAdapter: boolean enable()>
<android.media.AudioManager: void startBluetoothSco()>
<android.bluetooth.BluetoothA2dp: boolean isA2dpPlaying(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>
<android.nfc.NfcAdapter: void dispatch(android.nfc.Tag)>
<android.bluetooth.BluetoothHeadset: int getPriority(android.bluetooth.BluetoothDevice)>
<android.net.ConnectivityManager: int startUsingNetworkFeature(int,java.lang.String)>
<android.bluetooth.BluetoothHeadset: boolean stopVoiceRecognition(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothHeadset: boolean setPriority(android.bluetooth.BluetoothDevice,int)>
<android.bluetooth.BluetoothA2dp: boolean disconnect(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothHeadset: boolean disconnect(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothA2dp: boolean setPriority(android.bluetooth.BluetoothDevice,int)>
<android.bluetooth.BluetoothHeadset: boolean startVoiceRecognition(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothHeadset: boolean connect(android.bluetooth.BluetoothDevice)>
<android.media.AudioManager: void stopBluetoothSco()>
<android.bluetooth.BluetoothAdapter: boolean setName(java.lang.String)>
<android.net.ConnectivityManager: void setNetworkPreference(int)>
<android.bluetooth.BluetoothA2dp: boolean connect(android.bluetooth.BluetoothDevice)>
<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,java.lang.String)>
<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>
<android.bluetooth.BluetoothAdapter: boolean disable()>
Permission:android.permission.VIBRATE
8 Callers:
<android.app.DownloadManager: android.net.Uri getUriForDownloadedFile(long)>

# REDUNDANT_API Manual inspection shows this method only delegates to other monitored method (the killBackgroundProcesses)
# <android.app.NotificationManager: void notify(int,android.app.Notification)>

# SKIPPED_API non-abstract only in API 21 and up.
#   non-abstract: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/os/Vibrator.java
#   abstract: https://android.googlesource.com/platform/frameworks/base/+/android-4.4.2_r2.0.1/core/java/android/os/Vibrator.java

# NON_SUPPORTED_API Right now the Vibrator is just not monitored: for explanation, see email Konrad sent to Philipp on Feb 1, 2015, 16:53.
# <android.os.Vibrator: void vibrate(long[],int)>
# SKIPPED_API reason as with API above.
# <android.os.Vibrator: void vibrate(long)>

<android.app.DownloadManager: long addCompletedDownload(java.lang.String,java.lang.String,boolean,java.lang.String,java.lang.String,long,boolean)>
<android.app.DownloadManager: long enqueue(android.app.DownloadManager$Request)>
<android.app.NotificationManager: void notify(java.lang.String,int,android.app.Notification)>

# SKIPPED_API: abstract method
# <android.os.Vibrator: void cancel()>

Permission:android.permission.MODIFY_AUDIO_SETTINGS
18 Callers:
<android.media.AudioManager: void setMode(int)>
<android.inputmethodservice.KeyboardView: boolean onLongPress(android.inputmethodservice.Keyboard$Key)>
<android.media.AudioManager: void startBluetoothSco()>
<android.media.AudioManager: void setSpeakerphoneOn(boolean)>

# SKIPPED_APIs appguard fails to generate trampolines on Nexus 7
# <android.net.sip.SipAudioCall: void setSpeakerMode(boolean)>

<android.media.AudioManager: void setBluetoothScoOn(boolean)>
<android.media.AudioManager: void setMicrophoneMute(boolean)>
<android.media.AudioManager: void setParameter(java.lang.String,java.lang.String)>
<android.bluetooth.BluetoothHeadset: boolean stopVoiceRecognition(android.bluetooth.BluetoothDevice)>
<android.app.KeyguardManager: void exitKeyguardSecurely(android.app.KeyguardManager$OnKeyguardExitResult)>
<android.media.AudioManager: boolean isWiredHeadsetOn()>
<android.inputmethodservice.KeyboardView: void setKeyboard(android.inputmethodservice.Keyboard)>
<android.inputmethodservice.KeyboardView: boolean onTouchEvent(android.view.MotionEvent)>
<android.bluetooth.BluetoothHeadset: boolean startVoiceRecognition(android.bluetooth.BluetoothDevice)>
<android.inputmethodservice.KeyboardView: boolean onHoverEvent(android.view.MotionEvent)>
<android.media.AudioManager: void stopBluetoothSco()>
<android.media.AudioManager: void setParameters(java.lang.String)>
<android.media.AudioManager: boolean isBluetoothA2dpOn()>
Permission:android.permission.RESTART_PACKAGES
2 Callers:
# REDUNDANT_API Manual inspection shows this method only delegates to other monitored method (the killBackgroundProcesses)
# <android.app.ActivityManager: void restartPackage(java.lang.String)>
<android.app.ActivityManager: void killBackgroundProcesses(java.lang.String)>
Permission:android.permission.ACCESS_COARSE_LOCATION
20 Callers:
<android.location.LocationManager: void requestLocationUpdates(long,float,android.location.Criteria,android.location.LocationListener,android.os.Looper)>
<android.location.LocationManager: java.util.List getProviders(android.location.Criteria,boolean)>
<android.location.LocationManager: void requestSingleUpdate(android.location.Criteria,android.app.PendingIntent)>
<android.location.LocationManager: android.location.LocationProvider getProvider(java.lang.String)>
<android.location.LocationManager: android.location.Location getLastKnownLocation(java.lang.String)>
<android.location.LocationManager: boolean isProviderEnabled(java.lang.String)>
<android.location.LocationManager: void addProximityAlert(double,double,float,long,android.app.PendingIntent)>
<android.location.LocationManager: void requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener)>
<android.location.LocationManager: java.lang.String getBestProvider(android.location.Criteria,boolean)>
<android.telephony.TelephonyManager: java.util.List getNeighboringCellInfo()>
<android.telephony.TelephonyManager: android.telephony.CellLocation getCellLocation()>
<android.telephony.TelephonyManager: void listen(android.telephony.PhoneStateListener,int)>
<android.location.LocationManager: java.util.List getProviders(boolean)>
<android.location.LocationManager: void requestLocationUpdates(long,float,android.location.Criteria,android.app.PendingIntent)>
<android.location.LocationManager: void requestLocationUpdates(java.lang.String,long,float,android.app.PendingIntent)>
<android.location.LocationManager: boolean sendExtraCommand(java.lang.String,java.lang.String,android.os.Bundle)>
<android.location.LocationManager: void requestSingleUpdate(java.lang.String,android.location.LocationListener,android.os.Looper)>
<android.location.LocationManager: void requestSingleUpdate(android.location.Criteria,android.location.LocationListener,android.os.Looper)>
<android.location.LocationManager: void requestSingleUpdate(java.lang.String,android.app.PendingIntent)>
<android.location.LocationManager: void requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener,android.os.Looper)>
Permission:android.permission.CHANGE_NETWORK_STATE
4 Callers:
<android.net.ConnectivityManager: void setNetworkPreference(int)>
<android.net.ConnectivityManager: boolean requestRouteToHost(int,int)>
<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,java.lang.String)>
<android.net.ConnectivityManager: int startUsingNetworkFeature(int,java.lang.String)>
Permission:com.android.browser.permission.READ_HISTORY_BOOKMARKS
11 Callers:
<android.provider.Browser: void deleteFromHistory(android.content.ContentResolver,java.lang.String)>
<android.provider.Browser: void addSearchUrl(android.content.ContentResolver,java.lang.String)>
<android.provider.Browser: android.database.Cursor getAllVisitedUrls(android.content.ContentResolver)>
<android.provider.Browser: boolean canClearHistory(android.content.ContentResolver)>
<android.provider.Browser: void updateVisitedHistory(android.content.ContentResolver,java.lang.String,boolean)>
<android.provider.Browser: java.lang.String[] getVisitedHistory(android.content.ContentResolver)>
<android.provider.Browser: void truncateHistory(android.content.ContentResolver)>
<android.provider.Browser: void clearSearches(android.content.ContentResolver)>
<android.provider.Browser: void clearHistory(android.content.ContentResolver)>
<android.provider.Browser: android.database.Cursor getAllBookmarks(android.content.ContentResolver)>
<android.provider.Browser: void deleteHistoryTimeFrame(android.content.ContentResolver,long,long)>
Permission:android.permission.READ_USER_DICTIONARY
2 Callers:
<android.provider.UserDictionary$Words: void addWord(android.content.Context,java.lang.String,int,int)>
<android.provider.UserDictionary$Words: void addWord(android.content.Context,java.lang.String,int,java.lang.String,java.util.Locale)>
Permission:android.permission.WRITE_SETTINGS
20 Callers:
<android.media.RingtoneManager: void setActualDefaultRingtoneUri(android.content.Context,int,android.net.Uri)>
<android.provider.Settings$System: android.net.Uri getUriFor(java.lang.String)>
<android.provider.Settings$System: void setShowGTalkServiceStatus(android.content.ContentResolver,boolean)>
<android.net.wifi.WifiManager: void setCountryCode(java.lang.String,boolean)>
<android.provider.Settings$Secure: boolean putString(android.content.ContentResolver,java.lang.String,java.lang.String)>
<android.provider.Settings$Secure: boolean putLong(android.content.ContentResolver,java.lang.String,long)>
<android.provider.Settings$System: boolean putLong(android.content.ContentResolver,java.lang.String,long)>
<android.nfc.NfcAdapter: void dispatch(android.nfc.Tag)>
<android.provider.Settings$Secure: boolean putInt(android.content.ContentResolver,java.lang.String,int)>
<android.net.nsd.NsdManager: void setEnabled(boolean)>
<android.bluetooth.BluetoothHeadset: boolean setPriority(android.bluetooth.BluetoothDevice,int)>
<android.provider.Settings$Secure: boolean putFloat(android.content.ContentResolver,java.lang.String,float)>
<android.provider.Settings$System: boolean putInt(android.content.ContentResolver,java.lang.String,int)>
<android.bluetooth.BluetoothA2dp: boolean setPriority(android.bluetooth.BluetoothDevice,int)>
<android.provider.Settings$Secure: android.net.Uri getUriFor(java.lang.String)>
<android.provider.Settings$System: boolean putFloat(android.content.ContentResolver,java.lang.String,float)>
<android.provider.Settings$System: boolean putString(android.content.ContentResolver,java.lang.String,java.lang.String)>
<android.provider.Settings$System: boolean putConfiguration(android.content.ContentResolver,android.content.res.Configuration)>
<android.net.ConnectivityManager: void setNetworkPreference(int)>
<android.provider.Settings$Secure: void setLocationProviderEnabled(android.content.ContentResolver,java.lang.String,boolean)>
Permission:android.permission.READ_CALENDAR
6 Callers:
<android.provider.CalendarContract$Instances: android.database.Cursor query(android.content.ContentResolver,java.lang.String[],long,long)>
<android.provider.CalendarContract$CalendarAlerts: android.net.Uri insert(android.content.ContentResolver,long,long,long,long,int)>
<android.provider.CalendarContract$EventDays: android.database.Cursor query(android.content.ContentResolver,int,int,java.lang.String[])>
<android.provider.CalendarContract$Instances: android.database.Cursor query(android.content.ContentResolver,java.lang.String[],long,long,java.lang.String)>
<android.provider.CalendarContract$Attendees: android.database.Cursor query(android.content.ContentResolver,long,java.lang.String[])>
<android.provider.CalendarContract$Reminders: android.database.Cursor query(android.content.ContentResolver,long,java.lang.String[])>
Permission:android.permission.CAMERA
2 Callers:
<android.media.MediaRecorder: void setVideoSource(int)>
<android.hardware.Camera: android.hardware.Camera open()>
Permission:android.permission.WRITE_USER_DICTIONARY
2 Callers:
<android.provider.UserDictionary$Words: void addWord(android.content.Context,java.lang.String,int,int)>
<android.provider.UserDictionary$Words: void addWord(android.content.Context,java.lang.String,int,java.lang.String,java.util.Locale)>
Permission:android.permission.AUTHENTICATE_ACCOUNTS
7 Callers:
<android.accounts.AccountManager: void setUserData(android.accounts.Account,java.lang.String,java.lang.String)>
<android.accounts.AccountManager: void setPassword(android.accounts.Account,java.lang.String)>
<android.accounts.AccountManager: java.lang.String getPassword(android.accounts.Account)>
<android.accounts.AccountManager: boolean addAccountExplicitly(android.accounts.Account,java.lang.String,android.os.Bundle)>
<android.accounts.AccountManager: java.lang.String peekAuthToken(android.accounts.Account,java.lang.String)>
<android.accounts.AccountManager: java.lang.String getUserData(android.accounts.Account,java.lang.String)>
<android.accounts.AccountManager: void setAuthToken(android.accounts.Account,java.lang.String,java.lang.String)>

Permission:android.permission.INTERNET
26 Callers:

# SKIPPED_API NON_SUPPORTED_API INsdManager is a service-private class, see line 232 in: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/net/nsd/NsdManager.java
# <android.net.nsd.NsdManager: void <init>(android.content.Context,android.net.nsd.INsdManager)>

<android.app.DownloadManager: android.net.Uri getUriForDownloadedFile(long)>
<java.net.ServerSocket: void bind(java.net.SocketAddress)>

# REDUNDANT_API Manual inspection shows this method only delegates to other monitored method
# <java.net.URL: java.io.InputStream openStream()>

# SKIPPED_API not found in src: https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/java/net/NetworkInterface.java
# <java.net.NetworkInterface: void <init>(int)>

# ADDED_API src: line 52 in https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/java/net/NetworkInterface.java
# Manual analysis shows no permission check.
# <java.net.NetworkInterface: void <init>(java.lang.String,int,java.util.List,java.util.List)>

# REDUNDANT_API Manual inspection shows this method only delegates to other monitored method (the killBackgroundProcesses)
# <android.webkit.WebView: void <init>(android.content.Context)>

<java.net.URL: java.net.URLConnection openConnection()>

# SKIPPED_API not present in the src: https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/java/net/Socket.java
# <java.net.Socket: void <init>(int)>

# ADDED_APIs all public and protected non-trivial (not only delegating to other ctor) socket constructors.
# Src: https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/java/net/Socket.java

<java.net.Socket: void <init>()>
<java.net.Socket: void <init>(java.net.Proxy)>

# REDUNDANT_API
# <java.net.Socket: void <init>(java.lang.String,int)>

<java.net.Socket: void <init>(java.lang.String,int,java.net.InetAddress,int)>
<java.net.Socket: void <init>(java.lang.String,int,boolean)>
<java.net.Socket: void <init>(java.net.InetAddress,int,java.net.InetAddress,int)>
<java.net.Socket: void <init>(java.net.InetAddress,int,boolean)>
<java.net.Socket: void <init>(java.net.SocketImpl)>
# end of ADDED_APIs

<java.net.MulticastSocket: void <init>(int)>

# REDUNDANT_API Manual inspection shows this method only delegates to other monitored method
# <java.net.URL: java.lang.Object getContent()>

<android.webkit.WebView: void <init>(android.content.Context,android.util.AttributeSet,int,java.util.Map,boolean)>
<java.net.URLConnection: java.io.InputStream getInputStream()>

# SKIPPED_API not found in src: https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/java/net/HttpURLConnection.java
# <java.net.HttpURLConnection: void <init>(int)>

# ADDED_API: Called by the skipped API above, src: https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/java/net/URLConnection.java
<java.net.URLConnection: void <init>(java.net.URL)>

<android.webkit.WebViewFragment: android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle)>

# REDUNDANT_API Manual inspection shows this method only delegates to other monitored method
# <android.webkit.WebView: void <init>(android.content.Context,android.util.AttributeSet,int,boolean)>

<java.net.ServerSocket: void <init>(int)>

# SKIPPED_API not actually present in the class source: inherited from AbstractHttpClient
# src: https://android.googlesource.com/platform/external/apache-http/+/master/src/org/apache/http/impl/client/AbstractHttpClient.java
# <org.apache.http.impl.client.DefaultHttpClient: org.apache.http.HttpResponse execute(org.apache.http.client.methods.HttpUriRequest)>

# ADDED_APIs The execute() calls below replace the above-given skipped one. See also: src link above.

# REDUNDANT_API
# <org.apache.http.impl.client.AbstractHttpClient: org.apache.http.HttpResponse execute(org.apache.http.client.methods.HttpUriRequest)>

# REDUNDANT_API
# <org.apache.http.impl.client.AbstractHttpClient: org.apache.http.HttpResponse execute(org.apache.http.client.methods.HttpUriRequest,org.apache.http.protocol.HttpContext)>

# NON-REDUNDANT_API
<org.apache.http.impl.client.AbstractHttpClient: org.apache.http.HttpResponse execute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.protocol.HttpContext)>

# REDUNDANT_API
# <org.apache.http.impl.client.AbstractHttpClient: <T>_T execute(org.apache.http.client.methods.HttpUriRequest,org.apache.http.client.ResponseHandler<?_extends_T>,org.apache.http.protocol.HttpContext)>

# REDUNDANT_API
# <org.apache.http.impl.client.AbstractHttpClient: <T>_T execute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.client.ResponseHandler<?_extends_T>,org.apache.http.protocol.HttpContext)>

# End of added APIs.

# SKIPPED_API doesn't exist in the src: https://android.googlesource.com/platform/external/apache-http/+/master/src/org/apache/http/impl/client/DefaultHttpClient.java
# <org.apache.http.impl.client.DefaultHttpClient: void <init>(int)>

# REDUNDANT_API ADDED_API: replacement for the skipped API above. Src: https://android.googlesource.com/platform/external/apache-http/+/master/src/org/apache/http/impl/client/AbstractHttpClient.java
# <org.apache.http.impl.client.AbstractHttpClient: void <init>(org.apache.http.conn.ClientConnectionManager,org.apache.http.params.HttpParams)>

# REDUNDANT_API Manual inspection shows this method only delegates to other monitored method
# <android.webkit.WebView: void <init>(android.content.Context,android.util.AttributeSet,int)>

<android.net.nsd.NsdManager: void init()>
<java.net.DatagramSocket: void <init>(int)>

# REDUNDANT_API Manual inspection shows this method only delegates to other monitored method
# <android.webkit.WebView: void <init>(android.content.Context,android.util.AttributeSet)>

<android.app.DownloadManager: long addCompletedDownload(java.lang.String,java.lang.String,boolean,java.lang.String,java.lang.String,long,boolean)>
<android.app.DownloadManager: long enqueue(android.app.DownloadManager$Request)>

# SKIPPED_API: Abstract method
# <java.net.URLConnection: void connect()>

# SKIPPED_API: Abstract method
# NON_SUPPORTED_API Seems like no implementation of connect can be monitored. See also comments to Vibrator.vibrate() skipped APIs.
# <java.net.HttpURLConnection: void connect()>

Permission:android.permission.SET_WALLPAPER
10 Callers:

# REDUNDANT_API Manual inspection shows this method delegates to other monitored method and has other, non-security-relevant behavior.
# <android.content.ContextWrapper: void setWallpaper(android.graphics.Bitmap)>

<android.app.WallpaperManager: void setBitmap(android.graphics.Bitmap)>

# REDUNDANT_API Manual inspection shows this method delegates to other monitored method and has other, non-security-relevant behavior.
# <android.content.ContextWrapper: void clearWallpaper()>

<android.app.WallpaperManager: void setStream(java.io.InputStream)>
<android.app.WallpaperManager: void clear()>

# SKIPPED_API abstract method
# <android.content.Context: void setWallpaper(android.graphics.Bitmap)>

# SKIPPED_API abstract method
# <android.content.Context: void setWallpaper(java.io.InputStream)>

# SKIPPED_API abstract method: http://developer.android.com/reference/android/content/Context.html#clearWallpaper%28%29
# <android.content.Context: void clearWallpaper()>

# REDUNDANT_API Manual inspection shows this method delegates to other monitored method and has other, non-security-relevant behavior.
# <android.content.ContextWrapper: void setWallpaper(java.io.InputStream)>

<android.app.WallpaperManager: void setResource(int)>
Permission:com.android.browser.permission.WRITE_HISTORY_BOOKMARKS
7 Callers:
<android.provider.Browser: void truncateHistory(android.content.ContentResolver)>
<android.provider.Browser: void deleteFromHistory(android.content.ContentResolver,java.lang.String)>
<android.provider.Browser: void addSearchUrl(android.content.ContentResolver,java.lang.String)>
<android.provider.Browser: void clearHistory(android.content.ContentResolver)>
<android.provider.Browser: void clearSearches(android.content.ContentResolver)>
<android.provider.Browser: void updateVisitedHistory(android.content.ContentResolver,java.lang.String,boolean)>
<android.provider.Browser: void deleteHistoryTimeFrame(android.content.ContentResolver,long,long)>
Permission:android.permission.DISABLE_KEYGUARD
3 Callers:
<android.app.KeyguardManager$KeyguardLock: void reenableKeyguard()>
<android.app.KeyguardManager$KeyguardLock: void disableKeyguard()>
<android.app.KeyguardManager: void exitKeyguardSecurely(android.app.KeyguardManager$OnKeyguardExitResult)>
Permission:android.permission.WRITE_SOCIAL_STREAM
17 Callers:
<android.provider.Contacts$People: void markAsContacted(android.content.ContentResolver,long)>
<android.provider.Contacts$ContactMethods: void addPostalLocation(android.content.Context,long,double,double)>
<android.provider.ContactsContract$ProfileSyncState: android.content.ContentProviderOperation newSetOperation(android.accounts.Account,byte[])>
<android.provider.ContactsContract$SyncState: void set(android.content.ContentProviderClient,android.accounts.Account,byte[])>
<android.provider.ContactsContract$RawContacts: android.net.Uri getContactLookupUri(android.content.ContentResolver,android.net.Uri)>
<android.provider.Contacts$People: android.net.Uri createPersonInMyContactsGroup(android.content.ContentResolver,android.content.ContentValues)>
<android.provider.Contacts$People: android.net.Uri addToGroup(android.content.ContentResolver,long,java.lang.String)>
<android.provider.Contacts$People: android.net.Uri addToMyContactsGroup(android.content.ContentResolver,long)>
<android.provider.Contacts$Settings: void setSetting(android.content.ContentResolver,java.lang.String,java.lang.String,java.lang.String)>
<android.provider.ContactsContract$SyncState: android.content.ContentProviderOperation newSetOperation(android.accounts.Account,byte[])>
<android.provider.ContactsContract$Contacts: android.net.Uri getLookupUri(android.content.ContentResolver,android.net.Uri)>
<android.provider.ContactsContract$Contacts: void markAsContacted(android.content.ContentResolver,long)>
<android.provider.ContactsContract$Contacts: android.net.Uri getLookupUri(long,java.lang.String)>
<android.provider.ContactsContract$ProfileSyncState: void set(android.content.ContentProviderClient,android.accounts.Account,byte[])>
<android.provider.Contacts$People: android.net.Uri addToGroup(android.content.ContentResolver,long,long)>
<android.provider.ContactsContract$Directory: void notifyDirectoryChange(android.content.ContentResolver)>
<android.provider.ContactsContract$Data: android.net.Uri getContactLookupUri(android.content.ContentResolver,android.net.Uri)>
Permission:android.permission.WRITE_EXTERNAL_STORAGE
3 Callers:
<android.app.DownloadManager: android.net.Uri getUriForDownloadedFile(long)>
<android.app.DownloadManager: long enqueue(android.app.DownloadManager$Request)>
<android.app.DownloadManager: long addCompletedDownload(java.lang.String,java.lang.String,boolean,java.lang.String,java.lang.String,long,boolean)>
Permission:android.permission.ACCESS_NETWORK_STATE
8 Callers:
<android.net.ConnectivityManager: android.net.NetworkInfo getNetworkInfo(int)>
<android.net.ConnectivityManager: boolean isActiveNetworkMetered()>
<android.net.ConnectivityManager: int getNetworkPreference()>
<android.net.ConnectivityManager: void setNetworkPreference(int)>
<android.net.ConnectivityManager: android.net.NetworkInfo getActiveNetworkInfo()>
<android.net.ConnectivityManager: android.net.NetworkInfo[] getAllNetworkInfo()>
<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,java.lang.String)>
<android.net.ConnectivityManager: int startUsingNetworkFeature(int,java.lang.String)>
Permission:android.permission.REORDER_TASKS
2 Callers:
<android.app.ActivityManager: void moveTaskToFront(int,int)>
<android.app.ActivityManager: void moveTaskToFront(int,int,android.os.Bundle)>
Permission:android.permission.WRITE_CALENDAR
1 Callers:
<android.provider.CalendarContract$CalendarAlerts: android.net.Uri insert(android.content.ContentResolver,long,long,long,long,int)>
Permission:android.permission.GET_ACCOUNTS
24 Callers:
<android.provider.Browser: void deleteFromHistory(android.content.ContentResolver,java.lang.String)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture confirmCredentials(android.accounts.Account,android.os.Bundle,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture editProperties(java.lang.String,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthToken(android.accounts.Account,java.lang.String,android.os.Bundle,boolean,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.provider.Browser: void updateVisitedHistory(android.content.ContentResolver,java.lang.String,boolean)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthToken(android.accounts.Account,java.lang.String,boolean,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthTokenByFeatures(java.lang.String,java.lang.String,java.lang.String[],android.app.Activity,android.os.Bundle,android.os.Bundle,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture addAccount(java.lang.String,java.lang.String,java.lang.String[],android.os.Bundle,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.provider.Browser: void truncateHistory(android.content.ContentResolver)>
<android.provider.Browser: void clearSearches(android.content.ContentResolver)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAccountsByTypeAndFeatures(java.lang.String,java.lang.String[],android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: void addOnAccountsUpdatedListener(android.accounts.OnAccountsUpdateListener,android.os.Handler,boolean)>
<android.provider.Browser: void deleteHistoryTimeFrame(android.content.ContentResolver,long,long)>
<android.app.KeyguardManager: void exitKeyguardSecurely(android.app.KeyguardManager$OnKeyguardExitResult)>
<android.provider.Browser: void addSearchUrl(android.content.ContentResolver,java.lang.String)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture removeAccount(android.accounts.Account,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthToken(android.accounts.Account,java.lang.String,android.os.Bundle,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.Account[] getAccountsByType(java.lang.String)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthTokenLabel(java.lang.String,java.lang.String,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture updateCredentials(android.accounts.Account,java.lang.String,android.os.Bundle,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.provider.Browser: void clearHistory(android.content.ContentResolver)>
<android.accounts.AccountManager: android.accounts.Account[] getAccounts()>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture hasFeatures(android.accounts.Account,java.lang.String[],android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: java.lang.String blockingGetAuthToken(android.accounts.Account,java.lang.String,boolean)>
Permission:android.permission.READ_SYNC_STATS
9 Callers:
<android.content.ContentResolver: boolean isSyncActive(android.accounts.Account,java.lang.String)>
<android.test.mock.MockContentResolver: boolean isSyncActive(android.accounts.Account,java.lang.String)>
<android.test.mock.MockContentResolver: boolean isSyncPending(android.accounts.Account,java.lang.String)>
<android.test.SyncBaseInstrumentation: void syncProvider(android.net.Uri,java.lang.String,java.lang.String)>
<android.content.ContentResolver: android.content.SyncInfo getCurrentSync()>
<android.content.ContentResolver: java.util.List getCurrentSyncs()>
<android.test.mock.MockContentResolver: android.content.SyncInfo getCurrentSync()>
<android.content.ContentResolver: boolean isSyncPending(android.accounts.Account,java.lang.String)>
<android.test.mock.MockContentResolver: java.util.List getCurrentSyncs()>
Permission:android.permission.ACCESS_FINE_LOCATION
21 Callers:
<android.location.LocationManager: void requestLocationUpdates(long,float,android.location.Criteria,android.location.LocationListener,android.os.Looper)>
<android.location.LocationManager: java.util.List getProviders(android.location.Criteria,boolean)>
<android.location.LocationManager: void requestSingleUpdate(android.location.Criteria,android.app.PendingIntent)>
<android.location.LocationManager: android.location.LocationProvider getProvider(java.lang.String)>
<android.location.LocationManager: android.location.Location getLastKnownLocation(java.lang.String)>
<android.location.LocationManager: boolean isProviderEnabled(java.lang.String)>
<android.location.LocationManager: void addProximityAlert(double,double,float,long,android.app.PendingIntent)>
<android.location.LocationManager: void requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener)>
<android.location.LocationManager: java.lang.String getBestProvider(android.location.Criteria,boolean)>
<android.telephony.TelephonyManager: java.util.List getNeighboringCellInfo()>
<android.telephony.TelephonyManager: android.telephony.CellLocation getCellLocation()>
<android.location.LocationManager: java.util.List getProviders(boolean)>
<android.location.LocationManager: void requestLocationUpdates(long,float,android.location.Criteria,android.app.PendingIntent)>
<android.location.LocationManager: void requestLocationUpdates(java.lang.String,long,float,android.app.PendingIntent)>
<android.location.LocationManager: boolean sendExtraCommand(java.lang.String,java.lang.String,android.os.Bundle)>
<android.location.LocationManager: boolean addNmeaListener(android.location.GpsStatus$NmeaListener)>
<android.location.LocationManager: void requestSingleUpdate(java.lang.String,android.location.LocationListener,android.os.Looper)>
<android.location.LocationManager: void requestSingleUpdate(android.location.Criteria,android.location.LocationListener,android.os.Looper)>
<android.location.LocationManager: boolean addGpsStatusListener(android.location.GpsStatus$Listener)>
<android.location.LocationManager: void requestSingleUpdate(java.lang.String,android.app.PendingIntent)>
<android.location.LocationManager: void requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener,android.os.Looper)>
Permission:android.permission.USE_SIP
13 Callers:
# SKIPPED_APIs appguard fails to generate trampolines on Nexus 7
# <android.net.sip.SipManager: android.net.sip.SipSession getSessionFor(android.content.Intent)>
# <android.net.sip.SipManager: android.net.sip.SipAudioCall takeAudioCall(android.content.Intent,android.net.sip.SipAudioCall$Listener)>
# <android.net.sip.SipManager: void open(android.net.sip.SipProfile,android.app.PendingIntent,android.net.sip.SipRegistrationListener)>
# <android.net.sip.SipManager: android.net.sip.SipAudioCall makeAudioCall(android.net.sip.SipProfile,android.net.sip.SipProfile,android.net.sip.SipAudioCall$Listener,int)>
# <android.net.sip.SipManager: void register(android.net.sip.SipProfile,int,android.net.sip.SipRegistrationListener)>
# <android.net.sip.SipManager: boolean isOpened(java.lang.String)>
# <android.net.sip.SipManager: boolean isRegistered(java.lang.String)>
# <android.net.sip.SipManager: void open(android.net.sip.SipProfile)>
# <android.net.sip.SipManager: void unregister(android.net.sip.SipProfile,android.net.sip.SipRegistrationListener)>
# <android.net.sip.SipManager: android.net.sip.SipAudioCall makeAudioCall(java.lang.String,java.lang.String,android.net.sip.SipAudioCall$Listener,int)>
# <android.net.sip.SipManager: void close(java.lang.String)>
# <android.net.sip.SipManager: void setRegistrationListener(java.lang.String,android.net.sip.SipRegistrationListener)>
# <android.net.sip.SipManager: android.net.sip.SipSession createSipSession(android.net.sip.SipProfile,android.net.sip.SipSession$Listener)>
Permission:android.permission.USE_CREDENTIALS
11 Callers:
<android.accounts.AccountManager: android.accounts.AccountManagerFuture confirmCredentials(android.accounts.Account,android.os.Bundle,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture editProperties(java.lang.String,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthToken(android.accounts.Account,java.lang.String,android.os.Bundle,boolean,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthToken(android.accounts.Account,java.lang.String,android.os.Bundle,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthToken(android.accounts.Account,java.lang.String,boolean,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthTokenByFeatures(java.lang.String,java.lang.String,java.lang.String[],android.app.Activity,android.os.Bundle,android.os.Bundle,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture addAccount(java.lang.String,java.lang.String,java.lang.String[],android.os.Bundle,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture updateCredentials(android.accounts.Account,java.lang.String,android.os.Bundle,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: void invalidateAuthToken(java.lang.String,java.lang.String)>
<android.accounts.AccountManager: java.lang.String blockingGetAuthToken(android.accounts.Account,java.lang.String,boolean)>
<android.app.KeyguardManager: void exitKeyguardSecurely(android.app.KeyguardManager$OnKeyguardExitResult)>
Permission:android.permission.SET_TIME_ZONE
1 Callers:
<android.app.AlarmManager: void setTimeZone(java.lang.String)>
Permission:android.permission.WAKE_LOCK
45 Callers:
<android.widget.VideoView: boolean onKeyDown(int,android.view.KeyEvent)>

# SKIPPED_APIs appguard fails to generate trampolines on Nexus 7
# <android.net.sip.SipAudioCall: void onError(int,java.lang.String)>
# <android.net.sip.SipAudioCall: void close()>

<android.media.AsyncPlayer: void stop()>
<android.widget.VideoView: void resume()>
<android.media.RingtoneManager: void stopPreviousRingtone()>
<android.os.PowerManager$WakeLock: void finalize()>
<android.widget.VideoView: void setVideoURI(android.net.Uri,java.util.Map)>

# SKIPPED_API Moved to AppGuard API list
# <android.media.RingtoneManager: android.media.Ringtone getRingtone(int)>

# SKIPPED_APIs appguard fails to generate trampolines on Nexus 7
# <android.net.sip.SipManager: void close(java.lang.String)>

<android.media.Ringtone: void setUri(android.net.Uri)>
<android.media.MediaPlayer: void stop()>
<android.net.wifi.WifiManager$WifiLock: void finalize()>
<android.media.AsyncPlayer: void play(android.content.Context,android.net.Uri,boolean,int)>

# SKIPPED_APIs appguard fails to generate trampolines on Nexus 7
# <android.net.sip.SipAudioCall: void startAudio()>

<android.view.View: boolean startDrag(android.content.ClipData,android.view.View$DragShadowBuilder,java.lang.Object,int)>
<android.os.PowerManager$WakeLock: void release(int)>

# SKIPPED_APIs appguard fails to generate trampolines on Nexus 7
# <android.net.sip.SipManager: void open(android.net.sip.SipProfile,android.app.PendingIntent,android.net.sip.SipRegistrationListener)>

<android.media.effect.EffectContext: void release()>
<android.widget.VideoView: void setVideoPath(java.lang.String)>

# REDUNDANT_API Manual inspection shows this method delegates to other monitored method and has other, non-security-relevant behavior.
# <android.widget.VideoView: void stopPlayback()>

<android.media.MediaPlayer: void start()>
<android.bluetooth.BluetoothHeadset: boolean startVoiceRecognition(android.bluetooth.BluetoothDevice)>
<android.widget.VideoView: void suspend()>
<android.widget.VideoView: void pause()>

# REDUNDANT_API Manual inspection shows this method delegates to other monitored method and has other, non-security-relevant behavior.
# <android.widget.VideoView: void release(boolean)>

<android.media.Ringtone: void stop()>
<android.os.PowerManager$WakeLock: void acquire(long)>

# SKIPPED_API Private method: https://android.googlesource.com/platform/frameworks/base/+/master/media/java/android/media/RingtoneManager.java
# <android.media.RingtoneManager: android.media.Ringtone getRingtone(android.content.Context,android.net.Uri,int)>

<android.media.MediaPlayer: void setWakeMode(android.content.Context,int)>

# SKIPPED_APIs appguard fails to generate trampolines on Nexus 7
# <android.net.sip.SipAudioCall: void close(boolean)>

<android.media.Ringtone: void setStreamType(int)>
<android.os.PowerManager$WakeLock: void acquire()>
<android.net.wifi.WifiManager$WifiLock: void release()>
<android.net.wifi.WifiManager$WifiLock: void acquire()>

# REDUNDANT_API Manual inspection shows this method delegates to other monitored method and has other, non-security-relevant behavior.
# <android.widget.VideoView: void start()>

<android.media.MediaPlayer: void pause()>

# REDUNDANT_API Manual inspection shows this method only delegates to other monitored method.
# <android.widget.VideoView: void setVideoURI(android.net.Uri)>

<android.media.Ringtone: void play()>

# SKIPPED_API See previous occurence of this method for explanations.
# <android.os.Vibrator: void vibrate(long)>

<android.media.MediaPlayer: void reset()>

# SKIPPED_API Moved to appguard API list
# <android.media.RingtoneManager: android.media.Ringtone getRingtone(android.content.Context,android.net.Uri)>

# REDUNDANT_API Manual inspection shows this method only delegates to other monitored method
# <android.os.PowerManager$WakeLock: void release()>
<android.media.MediaPlayer: void release()>

# SKIPPED_APIs appguard fails to generate trampolines on Nexus 7
# <android.net.sip.SipAudioCall: void endCall()>

Permission:android.permission.READ_CONTACTS
26 Callers:
<android.provider.Contacts$People: void markAsContacted(android.content.ContentResolver,long)>
<android.provider.Contacts$ContactMethods: void addPostalLocation(android.content.Context,long,double,double)>
<android.widget.QuickContactBadge: void assignContactFromPhone(java.lang.String,boolean)>
<android.provider.ContactsContract$ProfileSyncState: byte[] get(android.content.ContentProviderClient,android.accounts.Account)>
<android.provider.ContactsContract$ProfileSyncState: android.content.ContentProviderOperation newSetOperation(android.accounts.Account,byte[])>
<android.provider.Contacts$People: android.database.Cursor queryGroups(android.content.ContentResolver,long)>
<android.provider.ContactsContract$SyncState: void set(android.content.ContentProviderClient,android.accounts.Account,byte[])>
<android.provider.ContactsContract$RawContacts: android.net.Uri getContactLookupUri(android.content.ContentResolver,android.net.Uri)>
<android.provider.Contacts$People: android.net.Uri createPersonInMyContactsGroup(android.content.ContentResolver,android.content.ContentValues)>
<android.provider.Contacts$People: android.net.Uri addToGroup(android.content.ContentResolver,long,java.lang.String)>
<android.provider.Contacts$People: android.net.Uri addToMyContactsGroup(android.content.ContentResolver,long)>
<android.provider.Contacts$Settings: void setSetting(android.content.ContentResolver,java.lang.String,java.lang.String,java.lang.String)>
<android.provider.ContactsContract$SyncState: android.content.ContentProviderOperation newSetOperation(android.accounts.Account,byte[])>
<android.provider.ContactsContract$SyncState: android.util.Pair getWithUri(android.content.ContentProviderClient,android.accounts.Account)>
<android.provider.ContactsContract$Contacts: android.net.Uri getLookupUri(android.content.ContentResolver,android.net.Uri)>
<android.provider.ContactsContract$Contacts: void markAsContacted(android.content.ContentResolver,long)>
<android.provider.ContactsContract$ProfileSyncState: android.util.Pair getWithUri(android.content.ContentProviderClient,android.accounts.Account)>
<android.widget.QuickContactBadge: void onClick(android.view.View)>
<android.provider.ContactsContract$SyncState: byte[] get(android.content.ContentProviderClient,android.accounts.Account)>
<android.widget.QuickContactBadge: void assignContactFromEmail(java.lang.String,boolean)>
<android.provider.ContactsContract$Contacts: android.net.Uri getLookupUri(long,java.lang.String)>
<android.provider.ContactsContract$ProfileSyncState: void set(android.content.ContentProviderClient,android.accounts.Account,byte[])>
<android.provider.ContactsContract$Directory: void notifyDirectoryChange(android.content.ContentResolver)>
<android.provider.Contacts$People: android.net.Uri addToGroup(android.content.ContentResolver,long,long)>
<android.provider.Contacts$Settings: java.lang.String getSetting(android.content.ContentResolver,java.lang.String,java.lang.String)>
<android.provider.ContactsContract$Data: android.net.Uri getContactLookupUri(android.content.ContentResolver,android.net.Uri)>
Permission:android.permission.SET_WALLPAPER_HINTS
1 Callers:
<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>
Permission:android.permission.READ_SYNC_SETTINGS
25 Callers:
<android.content.ContentResolver: boolean getMasterSyncAutomatically()>
<android.content.ContentResolver: java.util.List getPeriodicSyncs(android.accounts.Account,java.lang.String)>
<android.provider.Contacts$People: void markAsContacted(android.content.ContentResolver,long)>
<android.provider.Contacts$ContactMethods: void addPostalLocation(android.content.Context,long,double,double)>
<android.test.mock.MockContentResolver: boolean getSyncAutomatically(android.accounts.Account,java.lang.String)>
<android.provider.ContactsContract$ProfileSyncState: android.content.ContentProviderOperation newSetOperation(android.accounts.Account,byte[])>
<android.provider.ContactsContract$SyncState: void set(android.content.ContentProviderClient,android.accounts.Account,byte[])>
<android.provider.ContactsContract$RawContacts: android.net.Uri getContactLookupUri(android.content.ContentResolver,android.net.Uri)>
<android.provider.Contacts$People: android.net.Uri createPersonInMyContactsGroup(android.content.ContentResolver,android.content.ContentValues)>
<android.provider.Contacts$People: android.net.Uri addToGroup(android.content.ContentResolver,long,java.lang.String)>
<android.provider.Contacts$People: android.net.Uri addToMyContactsGroup(android.content.ContentResolver,long)>
<android.test.mock.MockContentResolver: int getIsSyncable(android.accounts.Account,java.lang.String)>
<android.provider.Contacts$Settings: void setSetting(android.content.ContentResolver,java.lang.String,java.lang.String,java.lang.String)>
<android.provider.ContactsContract$SyncState: android.content.ContentProviderOperation newSetOperation(android.accounts.Account,byte[])>
<android.provider.ContactsContract$Contacts: android.net.Uri getLookupUri(android.content.ContentResolver,android.net.Uri)>
<android.provider.ContactsContract$Contacts: void markAsContacted(android.content.ContentResolver,long)>
<android.content.ContentResolver: boolean getSyncAutomatically(android.accounts.Account,java.lang.String)>
<android.provider.ContactsContract$Contacts: android.net.Uri getLookupUri(long,java.lang.String)>
<android.test.mock.MockContentResolver: boolean getMasterSyncAutomatically()>
<android.provider.ContactsContract$ProfileSyncState: void set(android.content.ContentProviderClient,android.accounts.Account,byte[])>
<android.provider.ContactsContract$Directory: void notifyDirectoryChange(android.content.ContentResolver)>
<android.provider.Contacts$People: android.net.Uri addToGroup(android.content.ContentResolver,long,long)>
<android.test.mock.MockContentResolver: java.util.List getPeriodicSyncs(android.accounts.Account,java.lang.String)>
<android.content.ContentResolver: int getIsSyncable(android.accounts.Account,java.lang.String)>
<android.provider.ContactsContract$Data: android.net.Uri getContactLookupUri(android.content.ContentResolver,android.net.Uri)>
Permission:android.permission.WRITE_SYNC_SETTINGS
11 Callers:
<android.test.mock.MockContentResolver: void setIsSyncable(android.accounts.Account,java.lang.String,int)>
<android.test.SyncBaseInstrumentation: void cancelSyncsandDisableAutoSync()>
<android.content.ContentResolver: void addPeriodicSync(android.accounts.Account,java.lang.String,android.os.Bundle,long)>
<android.test.mock.MockContentResolver: void setSyncAutomatically(android.accounts.Account,java.lang.String,boolean)>
<android.content.ContentResolver: void setSyncAutomatically(android.accounts.Account,java.lang.String,boolean)>
<android.test.mock.MockContentResolver: void addPeriodicSync(android.accounts.Account,java.lang.String,android.os.Bundle,long)>
<android.content.ContentResolver: void setIsSyncable(android.accounts.Account,java.lang.String,int)>
<android.test.mock.MockContentResolver: void removePeriodicSync(android.accounts.Account,java.lang.String,android.os.Bundle)>
<android.content.ContentResolver: void setMasterSyncAutomatically(boolean)>
<android.content.ContentResolver: void removePeriodicSync(android.accounts.Account,java.lang.String,android.os.Bundle)>
<android.test.mock.MockContentResolver: void setMasterSyncAutomatically(boolean)>
Permission:android.permission.MANAGE_ACCOUNTS
16 Callers:
<android.accounts.AccountManager: android.accounts.AccountManagerFuture confirmCredentials(android.accounts.Account,android.os.Bundle,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture editProperties(java.lang.String,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthToken(android.accounts.Account,java.lang.String,android.os.Bundle,boolean,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture removeAccount(android.accounts.Account,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: void clearPassword(android.accounts.Account)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthToken(android.accounts.Account,java.lang.String,android.os.Bundle,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthTokenLabel(java.lang.String,java.lang.String,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthToken(android.accounts.Account,java.lang.String,boolean,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAuthTokenByFeatures(java.lang.String,java.lang.String,java.lang.String[],android.app.Activity,android.os.Bundle,android.os.Bundle,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture addAccount(java.lang.String,java.lang.String,java.lang.String[],android.os.Bundle,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture updateCredentials(android.accounts.Account,java.lang.String,android.os.Bundle,android.app.Activity,android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: void invalidateAuthToken(java.lang.String,java.lang.String)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture getAccountsByTypeAndFeatures(java.lang.String,java.lang.String[],android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: android.accounts.AccountManagerFuture hasFeatures(android.accounts.Account,java.lang.String[],android.accounts.AccountManagerCallback,android.os.Handler)>
<android.accounts.AccountManager: java.lang.String blockingGetAuthToken(android.accounts.Account,java.lang.String,boolean)>
<android.app.KeyguardManager: void exitKeyguardSecurely(android.app.KeyguardManager$OnKeyguardExitResult)>
Permission:android.permission.BROADCAST_STICKY
9 Callers:
<android.media.AudioManager: void setMode(int)>
<android.content.ContextWrapper: void removeStickyBroadcast(android.content.Intent)>

# SKIPPED_API abstract method
# <android.content.Context: void sendStickyBroadcast(android.content.Intent)>

<android.media.AudioManager: void startBluetoothSco()>
<android.content.ContextWrapper: void sendStickyOrderedBroadcast(android.content.Intent,android.content.BroadcastReceiver,android.os.Handler,int,java.lang.String,android.os.Bundle)>

# SKIPPED_API abstract method
# <android.content.Context: void removeStickyBroadcast(android.content.Intent)>

<android.media.AudioManager: void stopBluetoothSco()>
<android.content.ContextWrapper: void sendStickyBroadcast(android.content.Intent)>

# SKIPPED_API abstract method
# <android.content.Context: void sendStickyOrderedBroadcast(android.content.Intent,android.content.BroadcastReceiver,android.os.Handler,int,java.lang.String,android.os.Bundle)>

Permission:android.permission.ACCESS_LOCATION_EXTRA_COMMANDS
1 Callers:
<android.location.LocationManager: boolean sendExtraCommand(java.lang.String,java.lang.String,android.os.Bundle)>
Permission:android.permission.READ_SOCIAL_STREAM
26 Callers:
<android.provider.Contacts$People: void markAsContacted(android.content.ContentResolver,long)>
<android.provider.Contacts$ContactMethods: void addPostalLocation(android.content.Context,long,double,double)>
<android.widget.QuickContactBadge: void assignContactFromPhone(java.lang.String,boolean)>
<android.provider.ContactsContract$ProfileSyncState: byte[] get(android.content.ContentProviderClient,android.accounts.Account)>
<android.provider.ContactsContract$ProfileSyncState: android.content.ContentProviderOperation newSetOperation(android.accounts.Account,byte[])>
<android.provider.Contacts$People: android.database.Cursor queryGroups(android.content.ContentResolver,long)>
<android.provider.ContactsContract$SyncState: void set(android.content.ContentProviderClient,android.accounts.Account,byte[])>
<android.provider.ContactsContract$RawContacts: android.net.Uri getContactLookupUri(android.content.ContentResolver,android.net.Uri)>
<android.provider.Contacts$People: android.net.Uri addToGroup(android.content.ContentResolver,long,java.lang.String)>
<android.provider.Contacts$People: android.net.Uri createPersonInMyContactsGroup(android.content.ContentResolver,android.content.ContentValues)>
<android.provider.Contacts$People: android.net.Uri addToMyContactsGroup(android.content.ContentResolver,long)>
<android.provider.Contacts$Settings: void setSetting(android.content.ContentResolver,java.lang.String,java.lang.String,java.lang.String)>
<android.provider.ContactsContract$SyncState: android.util.Pair getWithUri(android.content.ContentProviderClient,android.accounts.Account)>
<android.provider.ContactsContract$SyncState: android.content.ContentProviderOperation newSetOperation(android.accounts.Account,byte[])>
<android.provider.ContactsContract$Contacts: android.net.Uri getLookupUri(android.content.ContentResolver,android.net.Uri)>
<android.provider.ContactsContract$Contacts: void markAsContacted(android.content.ContentResolver,long)>
<android.provider.ContactsContract$ProfileSyncState: android.util.Pair getWithUri(android.content.ContentProviderClient,android.accounts.Account)>
<android.widget.QuickContactBadge: void onClick(android.view.View)>
<android.provider.ContactsContract$SyncState: byte[] get(android.content.ContentProviderClient,android.accounts.Account)>
<android.widget.QuickContactBadge: void assignContactFromEmail(java.lang.String,boolean)>
<android.provider.ContactsContract$Contacts: android.net.Uri getLookupUri(long,java.lang.String)>
<android.provider.ContactsContract$ProfileSyncState: void set(android.content.ContentProviderClient,android.accounts.Account,byte[])>
<android.provider.Contacts$People: android.net.Uri addToGroup(android.content.ContentResolver,long,long)>
<android.provider.ContactsContract$Directory: void notifyDirectoryChange(android.content.ContentResolver)>
<android.provider.Contacts$Settings: java.lang.String getSetting(android.content.ContentResolver,java.lang.String,java.lang.String)>
<android.provider.ContactsContract$Data: android.net.Uri getContactLookupUri(android.content.ContentResolver,android.net.Uri)>
Permission:android.permission.READ_CALL_LOG
1 Callers:
<android.provider.CallLog$Calls: java.lang.String getLastOutgoingCall(android.content.Context)>
Permission:android.permission.KILL_BACKGROUND_PROCESSES
2 Callers:
<android.app.ActivityManager: void restartPackage(java.lang.String)>
<android.app.ActivityManager: void killBackgroundProcesses(java.lang.String)>
Permission:android.permission.BLUETOOTH
62 Callers:
<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>
<android.bluetooth.BluetoothDevice: java.lang.String getName()>
<android.bluetooth.BluetoothHeadset: java.util.List getDevicesMatchingConnectionStates(int[])>
<android.bluetooth.BluetoothHeadset: java.util.List getConnectedDevices()>
<android.media.AudioManager: void startBluetoothSco()>
<android.bluetooth.BluetoothDevice: android.bluetooth.BluetoothClass getBluetoothClass()>
<android.bluetooth.BluetoothHealth: int getConnectionState(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothSocket: void <init>(int,int,boolean,boolean,java.lang.String,int)>
<android.bluetooth.BluetoothAdapter: android.os.ParcelUuid[] getUuids()>
<android.bluetooth.BluetoothHeadset: boolean isAudioConnected(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothA2dp: java.util.List getConnectedDevices()>
<android.bluetooth.BluetoothHealth: boolean isEnabled()>
<android.bluetooth.BluetoothA2dp: boolean isEnabled()>
<android.net.ConnectivityManager: int startUsingNetworkFeature(int,java.lang.String)>
<android.bluetooth.BluetoothAdapter: java.util.Set getBondedDevices()>
<android.bluetooth.BluetoothHeadset: boolean stopVoiceRecognition(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>
<android.bluetooth.BluetoothHealth: boolean unregisterAppConfiguration(android.bluetooth.BluetoothHealthAppConfiguration)>
<android.bluetooth.BluetoothAdapter: android.bluetooth.BluetoothServerSocket listenUsingRfcommWithServiceRecord(java.lang.String,java.util.UUID)>
<android.bluetooth.BluetoothA2dp: boolean disconnect(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothA2dp: boolean setPriority(android.bluetooth.BluetoothDevice,int)>
<android.bluetooth.BluetoothAdapter: int getConnectionState()>
<android.bluetooth.BluetoothHeadset: boolean startVoiceRecognition(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothHeadset: boolean connect(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>
<android.net.ConnectivityManager: void setNetworkPreference(int)>
<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>
<android.bluetooth.BluetoothAdapter: boolean isEnabled()>
<android.bluetooth.BluetoothHealth: java.util.List getConnectedDevices()>
<android.bluetooth.BluetoothAdapter: java.lang.String getName()>
<android.bluetooth.BluetoothSocket: void <init>(int,int,boolean,boolean,android.bluetooth.BluetoothDevice,int,android.os.ParcelUuid)>
<android.bluetooth.BluetoothA2dp: java.util.List getDevicesMatchingConnectionStates(int[])>
<android.bluetooth.BluetoothA2dp: int getPriority(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothAdapter: int getScanMode()>
<android.media.AudioManager: void setMode(int)>
<android.bluetooth.BluetoothDevice: android.os.ParcelUuid[] getUuids()>
<android.bluetooth.BluetoothHeadset: boolean isEnabled()>
<android.bluetooth.BluetoothHealth: boolean disconnectChannel(android.bluetooth.BluetoothDevice,android.bluetooth.BluetoothHealthAppConfiguration,int)>
<android.bluetooth.BluetoothHealth: java.util.List getDevicesMatchingConnectionStates(int[])>
<android.bluetooth.BluetoothA2dp: boolean isA2dpPlaying(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothDevice: int getBondState()>
<android.bluetooth.BluetoothHealth: android.os.ParcelFileDescriptor getMainChannelFd(android.bluetooth.BluetoothDevice,android.bluetooth.BluetoothHealthAppConfiguration)>
<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>
<android.nfc.NfcAdapter: void dispatch(android.nfc.Tag)>
<android.bluetooth.BluetoothAdapter: java.lang.String getAddress()>
<android.bluetooth.BluetoothHeadset: int getPriority(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothA2dp: int getConnectionState(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothAdapter: android.bluetooth.BluetoothServerSocket listenUsingInsecureRfcommWithServiceRecord(java.lang.String,java.util.UUID)>
<android.bluetooth.BluetoothHeadset: boolean setPriority(android.bluetooth.BluetoothDevice,int)>
<android.bluetooth.BluetoothSocket: void connect()>
<android.bluetooth.BluetoothHeadset: boolean disconnect(android.bluetooth.BluetoothDevice)>
<android.bluetooth.BluetoothAdapter: int getState()>
<android.bluetooth.BluetoothHeadset: int getConnectionState(android.bluetooth.BluetoothDevice)>
<android.media.AudioManager: void stopBluetoothSco()>
<android.bluetooth.BluetoothServerSocket: void <init>(int,boolean,boolean,int)>
<android.bluetooth.BluetoothAdapter: boolean setName(java.lang.String)>
<android.bluetooth.BluetoothDevice: android.bluetooth.BluetoothSocket createRfcommSocketToServiceRecord(java.util.UUID)>
<android.bluetooth.BluetoothDevice: android.bluetooth.BluetoothSocket createInsecureRfcommSocketToServiceRecord(java.util.UUID)>
<android.bluetooth.BluetoothHealth: boolean registerSinkAppConfiguration(java.lang.String,int,android.bluetooth.BluetoothHealthCallback)>
<android.bluetooth.BluetoothA2dp: boolean connect(android.bluetooth.BluetoothDevice)>
<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,java.lang.String)>
<android.bluetooth.BluetoothHealth: boolean connectChannelToSource(android.bluetooth.BluetoothDevice,android.bluetooth.BluetoothHealthAppConfiguration)>
Permission:android.permission.RECORD_AUDIO
6 Callers:
<android.speech.SpeechRecognizer: void stopListening()>
<android.speech.SpeechRecognizer: void setRecognitionListener(android.speech.RecognitionListener)>
<android.speech.SpeechRecognizer: void cancel()>
<android.media.AudioRecord: void <init>(int,int,int,int,int)>
<android.speech.SpeechRecognizer: void startListening(android.content.Intent)>
<android.media.MediaRecorder: void setAudioSource(int)>

### ADDED_API Manually added handling of intents ###
# Reference: http://developer.android.com/guide/components/intents-filters.html

# Activity actions, as overridden by Activity class from base class of ContextWrapper.
# Manual inspection shows all other activity-related methods on Activity class delegate to the method set below.
<android.app.Activity: void startActivityForResult(android.content.Intent,int,android.os.Bundle)>
<android.app.Activity: void startActivities(android.content.Intent[],android.os.Bundle)>
<android.app.Activity: void startActivityFromChild(android.app.Activity,android.content.Intent,int,android.os.Bundle)>
<android.app.Activity: void startActivityFromFragment(android.app.Fragment,android.content.Intent,int,android.os.Bundle)>
<android.app.Activity: void startActivityIfNeeded(android.content.Intent,int,android.os.Bundle)>
<android.app.Activity: void startIntentSenderForResultInner(android.content.IntentSender,int,android.content.Intent,int,int,android.app.Activity,android.os.Bundle)>

# Activity actions on ContextWrapper. These methods won't be used by Activity class: instead, the methods whose monitoring is defined above will be.
# Commented out: instrumentation fails for unspecified reason. Instead, the corresponding set of methods on ContextImpl is monitored.
# <android.app.ContextWrapper: void startActivity(android.content.Intent)>
# <android.app.ContextWrapper: void startActivity(android.content.Intent,android.os.Bundle)>
# <android.app.ContextWrapper: void startActivityAsUser(android.content.Intent,android.os.Bundle,android.os.UserHandle)>
# <android.app.ContextWrapper: void startActivities(android.content.Intent[])>
# <android.app.ContextWrapper: void startActivities(android.content.Intent[],android.os.Bundle)>
# <android.app.ContextWrapper: void startActivitiesAsUser(android.content.Intent[],android.os.Bundle,android.os.UserHandle)>
# <android.app.ContextWrapper: void startIntentSender(android.content.IntentSender,android.content.Intent,int,int,int)>
# <android.app.ContextWrapper: void startIntentSender(android.content.IntentSender,android.content.Intent,int,int,int,android.os.Bundle)>

# Activity actions, as delegated to ContextImpl from e.g. ContextWrapper.
# Manual inspection shows all other activity-related methods on ContextImpl class delegate to the method set below.
# This set of method is inferior to the one of ContextWrapper defined above, but we use this set as the instrumentation actually works on it.
<android.app.ContextImpl: void startActivity(android.content.Intent,android.os.Bundle)>
<android.app.ContextImpl: void startActivityAsUser(android.content.Intent,android.os.Bundle,android.os.UserHandle)>
<android.app.ContextImpl: void startActivities(android.content.Intent[],android.os.Bundle)>
<android.app.ContextImpl: void startActivitiesAsUser(android.content.Intent[],android.os.Bundle,android.os.UserHandle)>
<android.app.ContextImpl: void startIntentSender(android.content.IntentSender,android.content.Intent,int,int,int,android.os.Bundle)>

# Service actions.
<android.content.ContextWrapper: android.content.ComponentName startService(android.content.Intent)>
<android.content.ContextWrapper: android.content.ComponentName startServiceAsUser(android.content.Intent,android.os.UserHandle)>
<android.content.ContextWrapper: boolean stopService(android.content.Intent)>
<android.content.ContextWrapper: boolean stopServiceAsUser(android.content.Intent,android.os.UserHandle)>
<android.content.ContextWrapper: boolean bindService(android.content.Intent,android.content.ServiceConnection,int)>
<android.content.ContextWrapper: boolean bindServiceAsUser(android.content.Intent,android.content.ServiceConnection,int,android.os.UserHandle)>
<android.content.ContextWrapper: void unbindService(android.content.ServiceConnection)>

# Service actions. Manual inspection shows all other service-related methods on ContextImpl (as well as Activity class) delegate to the method set below.
# Commented out, as the monitoring of ContextWrapper defined above should be enough.
# <android.app.ContextImpl: android.content.ComponentName startServiceCommon(android.content.Intent,android.os.UserHandle)>
# <android.app.ContextImpl: boolean stopServiceCommon(android.content.Intent,android.os.UserHandle)>

# Broadcast actions. Activity class service-related methods call these ContextWrapper methods.
<android.content.ContextWrapper: void sendBroadcast(android.content.Intent)>
<android.content.ContextWrapper: void sendBroadcast(android.content.Intent,java.lang.String)>
<android.content.ContextWrapper: void sendBroadcast(android.content.Intent,java.lang.String,int)>
<android.content.ContextWrapper: void sendOrderedBroadcast(android.content.Intent,java.lang.String)>
<android.content.ContextWrapper: void sendOrderedBroadcast(android.content.Intent,java.lang.String,android.content.BroadcastReceiver,android.os.Handler,int,java.lang.String,android.os.Bundle)>
<android.content.ContextWrapper: void sendOrderedBroadcast(android.content.Intent,java.lang.String,int,android.content.BroadcastReceiver,android.os.Handler,int,java.lang.String,android.os.Bundle)>
<android.content.ContextWrapper: void sendBroadcastAsUser(android.content.Intent,android.os.UserHandle)>
<android.content.ContextWrapper: void sendBroadcastAsUser(android.content.Intent,android.os.UserHandle,java.lang.String)>
<android.content.ContextWrapper: void sendOrderedBroadcastAsUser(android.content.Intent,android.os.UserHandle,java.lang.String,android.content.BroadcastReceiver,android.os.Handler,int,java.lang.String,android.os.Bundle)>

# Sticky broadcasts are handled by the mapping under Permission:android.permission.BROADCAST_STICKY

### End of handling of intents ###
